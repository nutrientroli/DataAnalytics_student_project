---
title: "Data Analytics - Práctica final"
author: "Daniel Moreno, Alessandro Bonifaccio y Raúl García"
date: "Diseñado por: Ester Bernadó"
output: 
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
---

# Introducción
****
El documento es el resultado del trabajo de un equipo formado por tres integrantes. En él, se muestra el código y las valoraciones realizadas sobre las preguntas proporcionadas.
Para realizar dicho documento, se ha considerado más oportuno tratar cada ejercicio como una unidad independiente. Facilitando su corrección y ejecución individual.
A continuación se describen que requisitos son necesarios y las funciones creadas para facilitar el desarrollo individual de cada ejercicio.

## Requisitos
### Librería "knitr"
Librería necesaria para poder generar el documento final de la práctica. Se trata de una librería que tiene como propósito generar reports de manera dinámica en R.
```{r, eval=TRUE, echo=TRUE}
library("knitr")
```

### Librería "dplyr"
Librería necesaria para facilitar la manipulación de datos. Proporciona más funcionalidades de manipulación de datos que el lenguaje de base.
```{r, eval=TRUE, echo=TRUE}
library("dplyr")
```

### Librería "lubridate"
Librería necesaria para facilitar la manipulación de fechas. Proporciona más funcionalidades de manipulación de fechas que el lenguaje de base.
```{r, eval=TRUE, echo=TRUE}
library("lubridate")
```

### Librería "ggplot2"
Librería necesaria para mejorar la visualización de los resultados obtenidos. Proporciona mejoras en la creación y visualización de diagramas. 
```{r, eval=TRUE, echo=TRUE}
library("ggplot2")
```

### Funciones
Para realizar dicho documento, se ha considerado más oportuno tratar cada ejercicio como una unidad independiente. Facilitando su corrección y ejecución individual. Por ese motivo, se ha creado una série de funciones de aspectos que se repeten en varios ejercicios.

```{r, eval=TRUE, echo=TRUE}

GetTrackinData = function() {
  data = read.csv("tracking.csv", sep = ",", na.strings = "NA")
  colnames(data)[4] = "SessionLenght"
  colnames(data)[5] = "MoneySpent"
  return(data)
}

GetUsersData = function() {
  data = read.csv("users.csv", sep = ",", na.strings = "NA")
  return(data)
}

```


****
# General overview of the data tracking
****

To have a general idea of what has been tracked and for how long, check the datasets provided and answer to
the following questions:

## How long is the tracking period?

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData();
  daysOfTracking = length(unique(trackingData$Date))
  
  #SHOW
  daysOfTracking #Hace Falta mostrarlo?
  paste("El total de dias de tracking es de unos ", daysOfTracking, " lo cual equivale a 4 meses de analisis")

```

## How many different users have installed the game?

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData();
  usersInstalledTheGame = unique(trackingData$UserID[trackingData$Action == "Install"])
  usersInstalledGameAmount = length(usersInstalledTheGame)
  
  #SHOW
  usersInstalledGameAmount #Hace Falta mostrarlo?
  paste("Las instalaciones son notorias sumando un total de ", usersInstalledGameAmount)
```

## How many different users have played the game during the tracking period?

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  usersPlayedGame = unique(trackingData$UserID[trackingData$Action == "Session"])
  usersPlayedGameAmount = length(usersPlayedGame)
  
  #SHOW
  usersPlayedGameAmount #Hace Falta mostrarlo?
  paste("De los usuarios que han jugado encontramos que " , usersPlayedGameAmount, " han jugado al juego")

```

## How many users have uninstalled the game?

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  usersUninstalledGame = unique(trackingData$UserID[trackingData$Action == "Uninstall"])
  usersUninstalledGameAmount = length(usersUninstalledGame)
  
  #SHOW
  usersUninstalledGameAmount #Hace Falta mostrarlo?
  paste("Los usuarios que han desintalado el juego, sin importar si lo juegan o no es de ", usersUninstalledGameAmount)

```

## What is the average of the number of sessions played by the users during the tracking period?

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  temp = trackingData[which(trackingData$Action == "Session"),]
  userSessionFreq = data.frame(table(temp$UserID))
  averageNofSessions = mean(userSessionFreq$Freq)
  
  #SHOW
  averageNofSessions #Hace Falta mostrarlo?
  paste("La media de número de sesiones realizadas por los usuarios es de ", averageNofSessions, "sesiones. Sobre este valor, hay que tener en cuenta que hay usuarios que aún habiendo instalado el juego, no han jugado.")
  

```

# Demographics of users

## What is the distribution of users that are playing the game, in terms of sex and age?

```{r, eval=TRUE, echo=TRUE}

  usersData = GetUsersData()

  #SHOW
  pie(table(usersData$sex), 
      main = "Sex distribtion of players", 
      labels = c("Females", "Males"), 
      col = rainbow(length(table(usersData$sex)))
      )
  
  print("Es apreciable una clara diferencia entre el numero de jugadores y jugadoras dentro de la muestra obtenida. Esto nos indica claramente que el publico principal del juego son hombres")
  
  barplot(table(usersData$age), 
          main = "Age distribution of users", 
          col = rainbow(length(table(usersData$age))),
          ylab = "User amount",
          xlab = "Age of user"
          )
  
  #print("VALORACION GRAFICO EDADES")
  
```

## What is the distribution of age of female players and male players?


```{r, eval=TRUE, echo=TRUE}
  
  usersData = GetUsersData()
  femaleSegment = usersData[usersData$sex == "F",]
  maleSegment = usersData[usersData$sex == "M",]

  #SHOW
  boxplot(femaleSegment$age, maleSegment$age, 
          main = "Female and Male age comparaison",
          names = c("Female Players", "Male Players"),
          col = c("Green","Blue"),
          ylab = "Age",
          xlab = "Population Sample")

  print ("El grafico nos muestra que existe una diferencia sustancial entre la edad en la cual las mujeres juegan y la edad en la que los hombres juegan. Encontramos una diferencia de edad de diez años entre las medias de ambos grupos. Lo que tambien es curioso es que los hombres de mas edad no juegan tanto como las mujeres de esa misma edad lo cual puede darse por varios motivos siendo uno de estos la menor esperanza de vida o la posibilidad de que no existan productos de entretenimiento adecuados para hombres de dicha edad")

```

## Conclusión del punto 2
```{r, eval=TRUE, echo=TRUE}
# Conclusión ----------------------------------------------------- //
  print("Encontramos que en este juego la mayoria de usuarios que lo juegan son hombres que en su mayoria se encuentran entre 30 y 40 años. Estos forman aproximadamente un 60% de la poblacion del juego. Encontramos ademas que el juego atrae la atencion de mujeres de entre 53 y 57 años. Estas ocupan un 40% aproximadamente de la muestra obtenida. En caso de necesidad seria primario centrarse en satisfacer al publico masculino antes que al femenino (en caso de necesidad claro esta).")
# ----------------------------------------------------------------- //

```

# Metrics of Player Population

## Installs per day

### How many installations are there per day? 

#### Draw a plot that shows the total number of installations per day. Also draw a line that shows the average of installations. Include a legend describing the two curves. 


```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  temp = trackingData[trackingData$Action == "Install",]
  installationsPerDay = temp %>% group_by(Date) %>% summarise(Installs = length(Action))
  installsAverage = mean(installationsPerDay$Installs)
  
  #SHOW
  #str(installationsPerDay)
  #installsAverage

  plot(installationsPerDay$Installs,
       main = "Installations per day Plot",
       ylab = "Instalations Per Day",
       xlab = "Day of mesure",
       type = "l",
       col = "blue"
       )
  abline(h = installsAverage, col = "green")
  legend(x = 30, y = 70,
         legend = c("Installations","Average of installtions"),
         bg = "grey",
         col=c("blue", "green"), 
         lty=1:1, 
         cex=0.8,
         title = "Type of lines")

  paste(" Por lo que indica el grafico podemos ver que las instalaciones medias al dia son unas ", installsAverage, " Es curiosa la tendencia de cada x dias sufrir una caida importante en cuanto a intalaciones. Esto puede deberse a las actividades externas. Debido a la edad de los jugadores podemos suponer que son momentos relacionados con la vida social y familiar ")




```

#### Draw a second plot where you show the same plot as before, together with the number of uninstallations per day.

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  
  temp = trackingData[trackingData$Action == "Uninstall",]
  unInstallationsPerDay = temp %>% group_by(Date) %>% summarise(Uninstalls = length(Action))
  uninstallsAverage = mean(unInstallationsPerDay$Uninstalls)

  temp = trackingData[trackingData$Action == "Install",]
  installationsPerDay = temp %>% group_by(Date) %>% summarise(Installs = length(Action))
  installsAverage = mean(installationsPerDay$Installs)

  plot(x = installationsPerDay$Installs,
       main = "Installations per day Plot",
       ylab = "Instalations Per Day",
       xlab = "Day of mesure",
       type = "l",
       col = c("blue","red"),
       ylim = c(0,max(installationsPerDay$Installs))
     ) 
  lines(unInstallationsPerDay$Uninstalls,
        type = "l",
        col = "red"
        ) 
  abline(h = installsAverage, col = "green")
  abline(h = uninstallsAverage, col = "orange")
  
  
  paste("Por suerte parece que la media de desintalaciones de la muestra ", uninstallsAverage, " es inferior a la media de instalaciones ", installsAverage, " lo cual es positivo debido a que significa que la poblacion formada por los usuarios con el juego instalado aumenta (esto no significa que lo jueguen). Si puediera superponer los graficos podria dar mas infomraicon pero por desgracia no consigo hacerlo por el momento")

```

## DAU

### Compute DAU (Daily Active Users) along the days of the tracking period and show a plot (x axis of the play represents the dates and y axis the value of DAU every day).

```{r, eval=TRUE, echo=TRUE}

## Compute DAU (Daily Active Users) along the days of the tracking period

  dte = as.Date(trackingData$Date)
  trackingData$Date = NULL;
  trackingData$Date = dte;

  trackingDataOnlySesions = trackingData[trackingData$Action == "Session",]
# trackingDataOnlySesions  

  sesionsPerDay = as.numeric(table(trackingDataOnlySesions$Date))

  sesionsPerDayWithMonth = as.data.frame(sesionsPerDay)
  sesionsPerDayWithMonth$Month = month(as.POSIXlt(unique( trackingDataOnlySesions$Date), format="%d/%m/%Y"))
  sesionsPerDayWithMonth

  plot(sesionsPerDay,
     type = "l",
     xlab = "Sample Day", 
     ylab = "Daily active users",
     main = "DAU",
     col = "dark green")

  paste("Poco depsues del primer mes podemos observar una estabilizacion de los usuarios activos del dia lo cual puede deberse a diversos motivos entre los cuales podemos encontrar primeramente un mayor numero de usuarios o una mayor retencion (especulacion). Por lo general es un crecimiento positivo aunque acaba estancandose alrededor de los 400 a partir del primer mes")

```

### After you plot DAU, draw the same plot, but now with two curves: one with DAU per day and the other one with installations per day. Thus, we can evaluate how DAU is related with the number of installations.

```{r, eval=TRUE, echo=TRUE}

  plot(sesionsPerDay,type = "l",
     xlab = "Sample Day", 
     ylab = "Amounts",
     col = "green", 
     main = "Daily Active users and installs")
  lines(installationsPerDay, col= "dark blue" )
  legend (x = 20, y = 200,
        legend = c ("Daily active users" , "Installs per Day"), 
        col = c("green", "dark blue"),
        text.col = c("green","dark blue"))

  paste("ADVERTENCIA: Es posible que este grafico no se vea tal y como es en la preview de rStudio")
  paste(" Como se podria esperar el ritmo de instalaciones durante el periodo de analisis se mantiene bastante estable con pequeños despuntes. Debido a las instalaciones que se realizan cada dia encontramos con que dia a dia los usuarios diarios activos")

#####
# Ejemplo
#x <- seq(-pi, pi, len = 65)
#plot(x, sin(x), type = "l", ylim = c(-1.2, 1.8), col = 3, lty = 2)
#points(x, cos(x), pch = 3, col = 4)
#lines(x, tan(x), type = "b", lty = 1, pch = 4, col = 6)
#title("legend(..., lty = c(2, -1, 1), pch = c(NA, 3, 4), merge = TRUE)",
#      cex.main = 1.1)
#legend(-1, 1.9, c("sin", "cos", "tan"), col = c(3, 4, 6),
#       text.col = "green4", lty = c(2, -1, 1), pch = c(NA, 3, 4),
#       merge = TRUE, bg = "gray90")
#####

```

## MAUU

### How much is MAUU?
#### Compute MAUU for each of the months of the tracking period and show it graphically.

```{r, eval=TRUE, echo=TRUE}
 
# Dates Info
# https://www.stat.berkeley.edu/~s133/dates.html

# Separemos cada mes y guardemos en este sus usuarios no repetidos

  monthsOfAnalisis = unique(month(as.POSIXlt(trackingData$Date, format="%d/%m/%Y")))
  monthsOfAnalisis
  trackingData$Month = month(as.POSIXlt(trackingData$Date, format="%d/%m/%Y"))
  monthsOfAnalisisName = unique(months(trackingData$Date))
  monthsOfAnalisisName


  GetUniqueUsersOfMonth = function(monthNumericIdentificator, dataStructure) {
      if(monthNumericIdentificator < 1 || monthNumericIdentificator > 12) {
        print("Unable to operate with month")
        return(NULL)
      }
      # Comparamos el mes de cada entrada dentro de la estructura de datos y lo comparamos con el mes que le hemos pedido que anlize
      monthDataFrame = dataStructure[ month(as.POSIXlt(trackingData$Date, format="%d/%m/%Y")) == monthNumericIdentificator, ]
      print("SUCCESS!")
      return (monthDataFrame)
  }

  maus = rep(1,length(monthsOfAnalisis))
  iterationIndex = 0
  # Iteramos por cada uno de los meses del analisis
  for(mth in monthsOfAnalisis) {
    iterationIndex = iterationIndex + 1
    monthDataFrame = GetUniqueUsersOfMonth(mth,trackingData)
    monthDataFrameOnlySesions = monthDataFrame[monthDataFrame$Action == "Session",]
    # cojemos de el data frame del mes la cantidad de entradas
    activeUsersOfMonth = as.numeric( table( monthDataFrameOnlySesions$Date)  )
    maus[iterationIndex] = activeUsersOfMonth
  }
# Generamos el plot

  plot (maus, 
      type = "l",
      xlab = "Month",
      ylab = "MAUU"
      ,xaxt="n", 
      col = "dark red",
      main = "MAUU per month of analisis")
  axis(side = 1,
     at = c(1,2,3,4),
     labels = monthsOfAnalisisName)

  paste("En la primera fase del despliegue del producto el MAUU parecer ser muy pequeño. Esto puedew deberse (y posiblemente se deba) a que la poblacion de jugadores diarios es aun muy limitada. En los siguientes meses se nota un incremento muy importante debido a que la poblacion ya esta establecida.")

```

## DAU/MAUU ratio
### How much is the DAU/MAUU ratio?
#### Compute DAU/MAUU per day of the month.

```{r, eval=TRUE, echo=TRUE}
  
  # Primero debemos saber el DAU --> Ya lo sabemos
  # Y despues conocer el MAUU del mes --> Ya lo tenemos

  #maus                # el mauu de cada mes
  #sesionsPerDayWithMonth       # BASICAMENTE EL DAU DE CADA DIA junto con el mes del cual sale
  #monthsOfAnalisis
  
  # separate the sesions per each month
  sesionsOfFirstMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[1],]
  sesionsSecondMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[2],]
  sesionsThirdMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[3],]
  sesionsForthMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[4],]
  
  sesionsOfFirstMonth
  maus[1]
  sesionsSecondMonth
  maus[2]             # hay un aumento muy imporntate en el mau de un mes para el otro
  sesionsThirdMonth
  maus[3]
  sesionsForthMonth
  maus[4]
  
  # Get for each day the relatio between the sesions / MAUU of the month of the day
  # first month sesions
  
  dauMauuFirstMonth = sesionsOfFirstMonth$sesionsPerDay / maus[1]
  dauMauuSecondMonth = sesionsSecondMonth$sesionsPerDay / maus[2]
  dauMauuThirdMonth = sesionsThirdMonth$sesionsPerDay / maus[3]
  dauMauuForthMonth = sesionsForthMonth$sesionsPerDay / maus[4]
  
  dauMauuAglomerated = c(dauMauuFirstMonth,dauMauuSecondMonth, dauMauuThirdMonth, dauMauuForthMonth)
  dauMauuAglomerated
  
  plot(dauMauuAglomerated)

```

#### Compute also the average DAU with respect to MAUU which will result in a single ratio per month

```{r, eval=TRUE, echo=TRUE}
  
  # no estoy seguro de si es esto lo que pide
  averageDauMaus = rep(-1,length(monthsOfAnalisis))
  averageDauMaus[1] = mean(dauMauuAglomerated[1])
  averageDauMaus[2] = mean(dauMauuAglomerated[2])
  averageDauMaus[3] = mean(dauMauuAglomerated[3])
  averageDauMaus[4] = mean(dauMauuAglomerated[4])
  
  averageDauMaus
  plot(averageDauMaus)
  
  # o esto (media de los dau de un mes partido el mauu de este)
  averageDaus = rep(-1,length(monthsOfAnalisis))
  averageDaus[1] = mean(sesionsOfFirstMonth$sesionsPerDay)
  averageDaus[2] = mean(sesionsSecondMonth$sesionsPerDay)
  averageDaus[3] = mean(sesionsThirdMonth$sesionsPerDay)
  averageDaus[4] = mean(sesionsForthMonth$sesionsPerDay)
  
  averageDauMauPerMonth = averageDaus / maus
  averageDauMauPerMonth
  
  plot (averageDauMauPerMonth, 
        xlab = "Months",
        ylab = "Average DAU/MAUU per month",
        type ="l",
        col = "blue")
  
```

# Gameplay Metrics
#### Now, the analysis looks at the gameplay metrics: number of sessions per user, play time of sessions, etc. 
#### Answer the following questions.

## Number of sessions per player
#### Compute the average number of sessions of the users. Show a histogram and/or boxplot and explain the result.

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  userSessionFreq = data.frame(table(temp$UserID))
  averageNofSessions = mean(userSessionFreq$Freq)
  
  #SHOW
  #mostrar la de cada usuario, el average total no hace falta no?
  
```


## Play time
### How much is the average time spent by the users in the playing sessions?
#### The dataset shows the time of each session of every day and every user. One way of looking at the time spent by user is to compute the average gamming time of every user (along the different sessions that each user plays) and the standart deviation. Compute this average and standart deviation. Then, plot the distribution of gaming time of the users as histogram. Interpret the results.

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  userSessionsAverage = data.frame(summarise(group_by(temp,UserID), TimeSession = mean(SessionLenght)))
  userSessionsAverageSD = data.frame(summarise(group_by(temp,UserID), TimeSession = sd(SessionLenght)))
  AvgTimeSpent = mean(userSessionsAverage$TimeSession)
  AvgStandarDeviation = mean(userSessionsAverageSD$TimeSession)
  
  #SHOW
  AvgTimeSpent
  AvgStandarDeviation
  #Mostrar en graficos el de cada usuario?
  
```


## Elapsed time between sessions
#### Compute the average time between sessions of each user and draw a boxplot or histogram. Interpret the results.

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  usersData = GetUsersData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  result = data.frame(cbind(UserID = as.character(usersData$UserID), AverageTimeBetweenSessions = rep("", nrow(usersData))), stringsAsFactors = FALSE)

  #check = temp[temp$UserID == "ID20005210",]
  
  #FOR a mejorar y optimizar ---> 7 minutos de cálculo...
  #Comentado para poder compilar documento sin esperar.
#  for(user in result$UserID){
#    prevDate = 0
#    sumTotal = 0
#    dates = c(as.character(temp[which(temp$UserID == user),]$Date))
#    if(length(dates)>1){
#      for (date in dates) {
#        if (prevDate!=0) {
#            sumTotal = sumTotal + as.numeric(as.character((as_date(as.character(date)) - as_date(as.character(prevDate)))))
#        }
#        prevDate = date
#      }
#      result[which(result$UserID == user), "AverageTimeBetweenSessions"] = sumTotal/(length(dates)-1)
#    }else{
#      result[which(result$UserID == user), "AverageTimeBetweenSessions"] = 0
#    }
#  }

  #SHOW
  #result
  
```


## Retention
#### Compute the retention at day 7, day 14, and day 30. Draw a plot that shows these retentions along the days.
#### **Tip** Since you will need to compute retention several times, the best way is to define a function that does this and that receives the necessary parameters. This is the header of the function:
#### Retention <- function (DS, dR)
#### where DS is the dataset, and dR is the retention that you will compute (D7, D14, D30). The function returns a vector with the specific retention computed along the days of tracking period.

```{r, eval=TRUE, echo=TRUE}
  
#Ya que mi Dani actual esta fuera de servicio te he dejado algo que puede serte de ayuda de parte de mi Dani pasado... Si no lo encuentras es que necesitas mas las gafas que yo :D 

RetentionOfTrackingData = function(DS, daysRetention){
  resultRetention = daysRetention
  index = 1

  for (day in daysRetention) {
    #DataFrame con user, dia instalacion y dia a comprovar.
    data_installs = data.frame(UserID=DS[which(DS$Action == "Install"),]$UserID, DateInstall=DS[which(DS$Action == "Install"),]$Date, DateRetention=rep("", nrow(DS[which(DS$Action == "Install"),])), stringsAsFactors=FALSE)
    data_installs[,'DateRetention'] = as_date(as.character(data_installs$DateInstall)) + day

    #DataFrame con user y dia de sesion
    data_sessions = data.frame(UserID=DS[which(DS$Action == "Session"),]$UserID, DateSession=DS[which(DS$Action == "Session"),]$Date)

    #DataFrame con user con instalacion, dia a comprovar y dia de sesion. Tantos registros de usuario por sesiones que existen.
    data_result = merge(data_installs, data_sessions, all.x=TRUE)

    #Calculos
      retention_users = 0
      for (user in unique(data_result$UserID)){

        if(is.element(unique(as.character(data_result[which(data_result$UserID == user),]$DateRetention)),as.character(data_result[which(data_result$UserID == user),]$DateSession))){

            retention_users = retention_users + 1
        }

      }
    resultRetention[index] = retention_users/length(unique(as.character(data_result$UserID)))
    index = index + 1

  }

  return(resultRetention)
}

Retention = RetentionOfTrackingData(GetTrackinData(), c(1,7,14,30))
Retention

daysToRetention = seq(from=1,to=30,by=1)
Retention = RetentionOfTrackingData(GetTrackinData(), daysToRetention)
plot(daysToRetention,Retention,
     xlab = "Dias",
     ylab = "Retencion",
     xlim = c(1,30),
     type ="l",
     col = "blue",
     )


#Retencion por dia de instalacion
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Install"),]
  dates = unique(as.character(temp$Date))
  
  retentionsA= rep(0, length(dates))
  retentionsB = rep(0, length(dates))
  index = 1
  for(date in dates){
      users = data.frame(UserID=as.character(temp[temp$Action == "Install" & as.character(temp$Date) == as.character(date),]$UserID))
      
      usersA = c(as.character(users[which(grepl("ID1" , users$UserID)),]))
      usersB = c(as.character(users[which(grepl("ID2" , users$UserID)),]))
     
      resultA = trackingData[which(is.element(as.character(trackingData$UserID), usersA)),]
      resultB = trackingData[which(is.element(as.character(trackingData$UserID), usersA)),]
    
      retentionsA[index]=RetentionOfTrackingData(resultA, c(14))
      retentionsB[index]=RetentionOfTrackingData(resultB, c(14))
      
      index=index+1
  }

  retentionsA
  retentionsB

```


# Game Industry Metrics
#### Now, the designers aim at investigating the common game industry metrics, i.e., the metrics that are related to monetization. Follow the guidelines provided. As always, you need to provide nice plots and tables, as required also explanations of the results obtained.

## Life Time
#### Compute the average life time of the users. Asume that the users that didn't uninstall the game are still active. Thus, compte LTV of those that are not active any more.

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Install"),]
  usersDateInstalledTheGame = data.frame(UserID=temp$UserID, DateInstall=temp$Date)

  temp = trackingData[which(trackingData$Action == "Uninstall"),]
  usersDateUninstalledTheGame = data.frame(UserID=temp$UserID, DateUnistall=temp$Date)

  usersDatesLifeTime = merge(usersDateInstalledTheGame,usersDateUninstalledTheGame, all.y=TRUE)

  usersDatesLifeTime = data.frame(usersDatesLifeTime,LifeTime=as_date(as.character(usersDatesLifeTime$DateUnistall)) - as_date(as.character(usersDatesLifeTime$DateInstall)))

  LT_average = mean(usersDatesLifeTime$LifeTime)
  
  #SHOW
  #usersDatesLifeTime$LifeTime
  LT_average

```


## Daily Revenue
#### Compute and plot the revenue per day and per month. Also compute the total revenue of the tracking period.

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersDateSessionsMoneySpent = data.frame(UserID=temp$UserID, Date=temp$Date, Money=temp$MoneySpent, DateMonth=month(as.POSIXlt(temp$Date, format="%Y-%m-%d")))
  
  sum(usersDateSessionsMoneySpent$Money)
  summarise(group_by(usersDateSessionsMoneySpent,Date),Revenue=sum(Money))
  summarise(group_by(usersDateSessionsMoneySpent,DateMonth), Revenue=sum(Money))

  #SHOW

```


## Conversion Rate
#### Compute the conversion rate of the users of the game. Explain the results.

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData()
  usersData = GetUsersData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersMoneySpent = data.frame(UserID=temp$UserID, Money=temp$MoneySpent)
  usersMoneySpent = usersMoneySpent[usersMoneySpent$Money>0,]
  usersMoneySpent = data.frame(summarise(group_by(usersMoneySpent,UserID), Revenue=sum(Money)))
  
  CR = nrow(usersMoneySpent)/nrow(usersData)

  #SHOW
```


## ARPU and ARPPU
#### Compute ARPU and ARPPU. Explain the results.

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData()
  usersData = GetUsersData()  
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersMoneySpent = data.frame(UserID=temp$UserID, Money=temp$MoneySpent)
  usersMoneySpent = usersMoneySpent[usersMoneySpent$Money>0,]
  usersMoneySpent = data.frame(summarise(group_by(usersMoneySpent,UserID), Revenue=sum(Money)))

  TotalRevenue = sum(usersMoneySpent$Revenue) 
  Users = nrow(data.frame(summarise(group_by(usersData, UserID))))
  PayUsers = nrow(usersMoneySpent)

  ARPU = TotalRevenue/Users
  ARPPU = TotalRevenue/PayUsers

  #SHOW

```


## LTV per user 
#### Compute LTV of every user and the average LTV of the users of the game. Since active users can be still contributing to the game, consider only those users that churned. Draw the distribution of TLV per user and also compute the average LTV.

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Uninstall"),]
  usersChurn = data.frame(UserID=temp$UserID)
  
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersMoneySpent = data.frame(UserID=temp$UserID, Money=temp$MoneySpent)
  usersMoneySpent = data.frame(summarise(group_by(usersMoneySpent,UserID), Revenue=sum(Money)))
  
  usersLTV = merge(usersChurn,usersMoneySpent, all.x=TRUE)
  usersLTV[is.na(usersLTV$Revenue),'Revenue'] = 0
  LTV = mean(usersLTV$Revenue)
  
  #SHOW
```


# A/B Test

## Retention
#### Using hypothesis testing, compute whether there are differences between the two versions of te game, with respect retention at day 14


```{r, eval=TRUE, echo=TRUE}
#1 Which type of inference is this (one sample or two sample)

# The inference we are facing in this exercise has two samples one for each version that we are analysing

#2 Write the null and alternative hypothesis
# Hº: Version 1 = Version 2
# H': Version 1 != Version 2

#3 Write which method is the most appropiate and why
# Due to the fact that we face a dataframe far beyond the 30's limit of T-student we should use the Normal Distribution. Also we currently have a bilateral graph.

#4 Compute the hypothesis testing

Group1 <- c(result$AverageTimeBetweenSessions)
length(Group1) <- length(Group1) / 100
Group2 <- c(sort(result$AverageTimeBetweenSessions, decreasing = TRUE))
length(Group2) <- length(Group2) / 100

Table1 <- data.frame(as.numeric(Group1) , as.numeric(Group2))

str(Table1)

MeanGroup1 <- mean(Table1$as.numeric.Group1.)
MeanGroup2 <- mean(Table1$as.numeric.Group2.)

StandardDeviationGroup1 <- sd(Table1$as.numeric.Group1.)
StandardDeviationGroup2 <- sd(Table1$as.numeric.Group2.)

n1 <- length(Table1$as.numeric.Group1.)
n2 <- length(Table1$as.numeric.Group2.)

df <- n1 + n2 - 2

s <- sqrt((((n1-1)*(StandardDeviationGroup1^2))+((n2-1)*(StandardDeviationGroup2^2))))/df

tobs <- (MeanGroup1 - MeanGroup2) / s * sqrt((1/n1) + (1/n2))

Quantile <- qt(0.05, df, lower.tail = TRUE)

#5 Compute the p-value

pt(tobs, df, lower.tail = TRUE)


#6 Interpret the results


```

##PlayTime of users
#### Can we conclude that the average play time of users that played versions 1 of the game is greater than those that played version 2? 

```{r, eval=TRUE, echo=TRUE}
trackingData = GetTrackinData()

temp = trackingData[which(trackingData$Action == "Session"),]

UsuariosVersion1 <- temp[which(grepl("ID1" , temp$UserID)),]
UsuariosVersion2 <- temp[which(grepl("ID2" , temp$UserID)),]

MG1 <- summarise(group_by(UsuariosVersion1, UserID), mean(SessionLenght))
MG2 <- summarise(group_by(UsuariosVersion2, UserID), mean(SessionLenght))

SDMG1 <- sd(UsuariosVersion1$SessionLenght)
SDMG2 <- sd(UsuariosVersion2$SessionLenght)


n1.1 <- length(UsuariosVersion1$SessionLenght)
n2.2 <- length(UsuariosVersion2$SessionLenght)

df2 <- (n1.1 + n2.2) - 2

s <- sqrt((((n1.1-1)*(SDMG1^2))+((n2.2-1)*(SDMG2^2))))/df2

zobs <- (MG1 - MG2) / s * sqrt((1/n1.1) + (1/n2.2))
```