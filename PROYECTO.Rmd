---
title: "Data Analytics - Práctica final"
author: "Daniel Moreno, Alessandro Bonifaccio y Raúl García"
date: "Diseñado por: Ester Bernadó"
output: 
  html_document:
    number_sections: yes
    toc: yes
    toc_depth: 2
---

# Introducción
****
El documento es el resultado del trabajo de un equipo formado por tres integrantes. En él, se muestra el código y las valoraciones realizadas sobre las preguntas proporcionadas.
Para realizar dicho documento, se ha considerado más oportuno tratar cada ejercicio como una unidad independiente. Facilitando su corrección y ejecución individual.
A continuación se describen que requisitos son necesarios y las funciones creadas para facilitar el desarrollo individual de cada ejercicio.

## Requisitos
### Librería "knitr"
Librería necesaria para poder generar el documento final de la práctica. Se trata de una librería que tiene como propósito generar reports de manera dinámica en R.
```{r, eval=FALSE, echo=TRUE, message=FALSE}
library("knitr")
```

### Librería "dplyr"
Librería necesaria para facilitar la manipulación de datos. Proporciona más funcionalidades de manipulación de datos que el lenguaje de base.
```{r eval=TRUE, echo=TRUE, message=FALSE}
library("dplyr")
```

### Librería "lubridate"
Librería necesaria para facilitar la manipulación de fechas. Proporciona más funcionalidades de manipulación de fechas que el lenguaje de base.
```{r, eval=TRUE, echo=TRUE, message=FALSE}
library("lubridate")
```

### Librería "ggplot2"
Librería necesaria para mejorar la visualización de los resultados obtenidos. Proporciona mejoras en la creación y visualización de diagramas. 
```{r, eval=TRUE, echo=TRUE, message=FALSE}
library("ggplot2")
```


### Funciones
Para realizar dicho documento, se ha considerado más oportuno tratar cada ejercicio como una unidad independiente. Facilitando su corrección y ejecución individual. Por ese motivo, se ha creado una série de funciones de aspectos que se repeten en varios ejercicios.

```{r, eval=TRUE, echo=TRUE}

GetTrackinData = function() {
  data = read.csv("tracking.csv", sep = ",", na.strings = "NA")
  colnames(data)[4] = "SessionLenght"
  colnames(data)[5] = "MoneySpent"
  return(data)
}

GetUsersData = function() {
  data = read.csv("users.csv", sep = ",", na.strings = "NA")
  return(data)
}

```

Además, se ha creado unas funciones extras para una utilidad muy concreta.

```{r, eval=TRUE, echo=TRUE}
GetUniqueUsersOfMonth = function(monthNumericIdentificator, dataStructure) {
  if(monthNumericIdentificator < 1 || monthNumericIdentificator > 12) {
        return(NULL)
  }
  monthDataFrame = dataStructure[month(as.POSIXlt(trackingData$Date, format="%d/%m/%Y")) == monthNumericIdentificator,]
  return (monthDataFrame)
}

RetentionOfTrackingData = function(DS, daysRetention){
  resultRetention = daysRetention
  index = 1

  for (day in daysRetention) {
    #DataFrame con user, dia instalacion y dia a comprovar.
    data_installs = data.frame(UserID=DS[which(DS$Action == "Install"),]$UserID, DateInstall=DS[which(DS$Action == "Install"),]$Date, DateRetention=rep("", nrow(DS[which(DS$Action == "Install"),])), stringsAsFactors=FALSE)
    data_installs[,'DateRetention'] = as_date(as.character(data_installs$DateInstall)) + day

    #DataFrame con user y dia de sesion
    data_sessions = data.frame(UserID=DS[which(DS$Action == "Session"),]$UserID, DateSession=DS[which(DS$Action == "Session"),]$Date)

    #DataFrame con user con instalacion, dia a comprovar y dia de sesion. Tantos registros de usuario por sesiones que existen.
    data_result = merge(data_installs, data_sessions, all.x=TRUE)

    #Calculos
      retention_users = 0
      for (user in unique(data_result$UserID)){

        if(is.element(unique(as.character(data_result[which(data_result$UserID == user),]$DateRetention)),as.character(data_result[which(data_result$UserID == user),]$DateSession))){

            retention_users = retention_users + 1
        }

      }
    resultRetention[index] = retention_users/length(unique(as.character(data_result$UserID)))
    index = index + 1

  }

  return(resultRetention)
}

```
  
****
# Resumen general
****

En este documento se realizan una série de cálculos de métricas y se realizan análisis sobre unos datos concretos. Éstos son un conjunto de datos obtenidos después de haberse realizado un seguimiento de acciones de cada usuario en un videojuego.

Por lo tanto, se puede observar dos ficheros con datos del "tracking" y con la base de usuarios del juego con datos sobre ellos.

Así pues, a continuación se describen y responden a una série de preguntas que ayudarán a entender mejor los datos que se manejan.

## ¿Cuánto tiempo dura el período de seguimiento?
```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData();
  daysOfTracking = length(unique(trackingData$Date))

```

El seguimiento dura un total de **`r toString(daysOfTracking)` días**.



## ¿Cuántos usuarios diferentes han instalado el juego?
```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData();
  usersInstalledTheGame = unique(trackingData$UserID[trackingData$Action == "Install"])
  usersInstalledGameAmount = length(usersInstalledTheGame)

```

El juego ha sido instalado por **`r toString(usersInstalledGameAmount)` usuarios** diferentes.



## ¿Cuántos usuarios diferentes han jugado durante el período de seguimiento?
```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  usersPlayedGame = unique(trackingData$UserID[trackingData$Action == "Session"])
  usersPlayedGameAmount = length(usersPlayedGame)

```

Durante el período de seguimiento han jugado **`r toString(usersPlayedGameAmount)` usuarios** diferentes.
Se observa que ha disminuido respecto los usuarios que tienen el juego intalado.



## ¿Cuántos usuarios diferentes han desinstalado el juego?
```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  usersUninstalledGame = unique(trackingData$UserID[trackingData$Action == "Uninstall"])
  usersUninstalledGameAmount = length(usersUninstalledGame)

```

Se observan **`r toString(usersUninstalledGameAmount)` usuarios** que han desinstalado el juego.



## ¿Cuál es el promedio del número de sesiones jugadas por los usuarios durante el período de seguimiento?
```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData();
  temp = trackingData[which(trackingData$Action == "Session"),]
  userSessionFreq = data.frame(table(temp$UserID))
  averageNofSessions = mean(userSessionFreq$Freq)

```

La media de número de sesiones realizadas por los usuarios ha sido de **`r toString(format(round(averageNofSessions, 2), nsmall = 2))` sesiones**. Sobre este valor, se ha de tener en cuenta que hay usuarios que aún habiendo instalado el juego, no han jugado.




# Demografía de los usuarios

## ¿Cuál es la distribución de los usuarios que participan en el juego, en términos de sexo y edad?
Si observamos el término de sexo:
```{r, eval=TRUE, echo=TRUE}

  usersData = GetUsersData()
  temp = table(usersData$sex)
  pie(temp, 
      main = "Distribución por sexo de los jugadores", 
      labels = c("Femenino", "Masculino"), 
      col = rainbow(length(temp))
      )
  
```  

Se aprecia una clara diferencia entre el número de jugadores masculinos (**`r toString(temp[2])`**) y el número de jugadoras femeninas (**`r toString(temp[1])`**).

Respecto al término de edad:
```{r, eval=TRUE, echo=TRUE} 
  
  usersData = GetUsersData()
  barplot(table(usersData$age), 
          main = "Distribución por edad de los usuarios", 
          col = rainbow(length(table(usersData$age))),
          ylab = "Usuarios (número de usuarios)",
          xlab = "Edad"
          )
  
```

Se observa una distribución estraña respecto la edad. Parece que el juego es atractivo para dos segementos de edad diferentes. Se aprecia que los segmentos son de los rangos de edad de los 30 a los 40 y de los 50 a los 60.



## ¿Cuál es la distribución de edad según el sexo de los jugadores?
```{r, eval=TRUE, echo=TRUE}
  
  usersData = GetUsersData()
  femaleSegment = usersData[usersData$sex == "F",]
  maleSegment = usersData[usersData$sex == "M",]
  boxplot(femaleSegment$age, maleSegment$age, 
          main = "Comparación de edad según sexo",
          names = c("Femenino", "Masculino"),
          col = c("Green","Blue"),
          ylab = "Edad",
          xlab = "Jugadores"
          )

```

El gráfico muestra que existe una diferencia sustancial entre la edad de los jugadores del sexo femenino y la edad en la que los jugadores del sexo masculino. Se observa una diferencia de edad de diez años entre las medias de ambos grupos.

También, es curioso que los jugadores (masculinos) de más edad no jueguen tanto como los jugadores del sexo femenino de esa misma edad. Este hecho puede darse por varios motivos siendo uno de éstos la menor esperanza de vida o la posibilidad de que no existan productos de entretenimiento adecuados para el sexo masculino de dicha edad.

Al observarse la gráfica final, se puede entender realmente el porque existía una distribución de edad estraña.




# Métricas de la población de jugadores

## Instalaciones al día

### ¿Cuántas instalaciones hay por día?

```{r, eval=TRUE, echo=TRUE}
  trackingData = GetTrackinData();
  temp = trackingData[trackingData$Action == "Install",]
  installationsPerDay = temp %>% group_by(Date) %>% summarise(Installs = length(Action))
  installsAverage = mean(installationsPerDay$Installs)
``` 

Al día se observa una media de **`r toString(format(round(installsAverage, 2), nsmall = 2))`** instalaciones.

```{r, eval=TRUE, echo=TRUE}
  plot(installationsPerDay$Installs,
       main = "Instalaciones por día",
       ylab = "Instalaciones",
       xlab = "Día",
       type = "l",
       col = "blue"
       )
  abline(h = installsAverage, col = "green")
  legend(x = 30, y = 70,
         legend = c("Instalaciones","Media de las instalaciones"),
         bg = "grey",
         col=c("blue", "green"), 
         lty=1:1, 
         cex=0.8,
         title = "Leyenda de las líneas")
```

En el gráfico se detallan caídas de número de instalaciones después de períodos con un buen número de instalaciones. Éste hecho, puede ser debido a actividades externas y factores que se desconocen en el estudio.

Si se compara con el número de desinstalaciones al día, se puede obtener información más detallada. Así como poder observar si tiene crecimiento real o no.

```{r, eval=TRUE, echo=TRUE}
  trackingData = GetTrackinData();
  
  temp = trackingData[trackingData$Action == "Uninstall",]
  unInstallationsPerDay = temp %>% group_by(Date) %>% summarise(Uninstalls = length(Action))
  uninstallsAverage = mean(unInstallationsPerDay$Uninstalls)

  temp = trackingData[trackingData$Action == "Install",]
  installationsPerDay = temp %>% group_by(Date) %>% summarise(Installs = length(Action))
  installsAverage = mean(installationsPerDay$Installs)

  plot(x = installationsPerDay$Installs,
       main = "Instalaciones y Desintalaciones por día",
       ylab = "Número de Acciones (instalar o desinstalar)",
       xlab = "Días",
       type = "l",
       col = c("blue","red"),
       ylim = c(0,max(installationsPerDay$Installs)+25)
       ) 
  lines(unInstallationsPerDay$Uninstalls,
        type = "l",
        col = "red"
        ) 
  abline(h = installsAverage, col = "green")
  abline(h = uninstallsAverage, col = "orange")
  legend(x = 30, y = 95,
         legend = c("Instalaciones","Desinstalaciones", "Media de instalaciones","Media de desinstalaciones"),
         bg = "grey",
         col=c("blue", "red", "green", "orange"), 
         lty=1:1, 
         cex=0.8,
         title = "Leyenda de las líneas")
```

La media de desintalaciones de la muestra (**`r toString(format(round(uninstallsAverage, 2), nsmall = 2))`**) es inferior a la media de instalaciones (**`r toString(format(round(installsAverage, 2), nsmall = 2))`**). Por lo tanto, se puede deducir que está en crecimiento de usuarios.



## DAU

### ¿Cuánto es el DAU?

```{r, eval=TRUE, echo=TRUE}
  trackingData = GetTrackinData();

  dtemp = as.Date(trackingData$Date)
  trackingData$Date = NULL;
  trackingData$Date = dtemp;

  trackingDataOnlySesions = trackingData[trackingData$Action == "Session",]

  sesionsPerDay = as.numeric(table(trackingDataOnlySesions$Date))

  sesionsPerDayWithMonth = as.data.frame(sesionsPerDay)
  sesionsPerDayWithMonth$Month = month(as.POSIXlt(unique( trackingDataOnlySesions$Date), format="%d/%m/%Y"))

  plot(sesionsPerDay,
     type = "l",
     xlab = "Días", 
     ylab = "DAU",
     main = "Progreso del DAU",
     col = "dark green")
```

Poco después del primer mes, se observa una estabilización de los usuarios activos al día. Puede deberse a diversos motivos entre los cuales se pueden encontrar primeramente un mayor número de usuarios o una mayor retención (especulación). Por lo general, es un crecimiento positivo aunque acaba estancándose alrededor de los 400 a partir del primer mes.

Para comprovar la valoración realizada sobre si el progreso del DAU aumenta debido a un número mayor de usuarios, se muestra a continuación una gráfica con dichos datos.

```{r, eval=TRUE, echo=TRUE}
  plot(sesionsPerDay,type = "l",
     xlab = "Días", 
     ylab = "Cantidad (DAU y instalaciones)",
     col = "dark green", 
     main = "Progreso del DAU y instalaciones")
  lines(installationsPerDay, col= "dark blue" )
  legend (x = 20, y = 200,
        legend = c ("DAU" , "Instalaciones"), 
        bg = "grey",
        col = c("dark green", "dark blue"),
        text.col = c("dark green","dark blue"),
        lty=1:1, 
        cex=0.8,
        title = "Leyenda de las líneas")
```

Como se puede esperar, el ritmo de instalaciones durante el período de análisis se mantiene estable con pequeños picos. Debido a las instalaciones que se realizan cada día, se observa que el DAU crece debido a los nuevos jugadores. Pero gracias al gráfico se extrae que los jugadores iniciales juegan al juego durante varios días. Permitiendo ver el progreso del DAU de este modo.


## MAUU

### ¿Cuánto es el MAUU?

```{r eval=TRUE, echo=TRUE, message=FALSE, warning=FALSE}
  
  #trackingData = GetTrackinData()

  monthsOfAnalisis = unique(month(as.POSIXlt(trackingData$Date, format="%d/%m/%Y")))
  trackingData$Month = month(as.POSIXlt(trackingData$Date, format="%d/%m/%Y"))
  monthsOfAnalisisName = unique(months(trackingData$Date))
  
  maus = rep(1,length(monthsOfAnalisis))
  iterationIndex = 0
  # Iteramos por cada uno de los meses del analisis
  for(mth in monthsOfAnalisis) {
    iterationIndex = iterationIndex + 1
    monthDataFrame = GetUniqueUsersOfMonth(mth,trackingData)
    monthDataFrameOnlySesions = monthDataFrame[monthDataFrame$Action == "Session",]
    # cojemos de el data frame del mes la cantidad de entradas
    activeUsersOfMonth = as.numeric(table(monthDataFrameOnlySesions$Date)  )
    maus[iterationIndex] = activeUsersOfMonth
  }

  plot (maus, 
      type = "l",
      xlab = "Mes",
      ylab = "MAUU",
      xaxt="n", 
      col = "dark red",
      main = "MAUU por mes")
  axis(side = 1,
       at = c(1,2,3,4),
       labels = monthsOfAnalisisName)
```

En la primera fase del despliegue del producto el MAUU parece ser pequeño debido a que la población de jugadores diarios es aún limitada. En los siguientes meses se percibe un incremento importante ya que la población ya esta establecida.



## Ratio DAU/MAUU
### ¿Cuánto es el ratio DAU/MAUU?

```{r, eval=TRUE, echo=TRUE}
  
  # Primero debemos saber el DAU --> Ya lo sabemos
  # Y despues conocer el MAUU del mes --> Ya lo tenemos

  #maus                # el mauu de cada mes
  #sesionsPerDayWithMonth       # BASICAMENTE EL DAU DE CADA DIA junto con el mes del cual sale
  #monthsOfAnalisis
  
  # separate the sesions per each month
  sesionsOfFirstMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[1],]
  sesionsSecondMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[2],]
  sesionsThirdMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[3],]
  sesionsForthMonth = sesionsPerDayWithMonth[sesionsPerDayWithMonth$Month == monthsOfAnalisis[4],]
  
  # Get for each day the relatio between the sesions / MAUU of the month of the day
  # first month sesions
  
  dauMauuFirstMonth = sesionsOfFirstMonth$sesionsPerDay / maus[1]
  dauMauuSecondMonth = sesionsSecondMonth$sesionsPerDay / maus[2]
  dauMauuThirdMonth = sesionsThirdMonth$sesionsPerDay / maus[3]
  dauMauuForthMonth = sesionsForthMonth$sesionsPerDay / maus[4]
  
  dauMauuAglomerated = c(dauMauuFirstMonth,dauMauuSecondMonth, dauMauuThirdMonth, dauMauuForthMonth)
  
  plot(dauMauuAglomerated)

```



```{r, eval=TRUE, echo=TRUE}
  
  # no estoy seguro de si es esto lo que pide
  averageDauMaus = rep(-1,length(monthsOfAnalisis))
  averageDauMaus[1] = mean(dauMauuAglomerated[1])
  averageDauMaus[2] = mean(dauMauuAglomerated[2])
  averageDauMaus[3] = mean(dauMauuAglomerated[3])
  averageDauMaus[4] = mean(dauMauuAglomerated[4])
  
  averageDauMaus
  plot(averageDauMaus)
  
  # o esto (media de los dau de un mes partido el mauu de este)
  averageDaus = rep(-1,length(monthsOfAnalisis))
  averageDaus[1] = mean(sesionsOfFirstMonth$sesionsPerDay)
  averageDaus[2] = mean(sesionsSecondMonth$sesionsPerDay)
  averageDaus[3] = mean(sesionsThirdMonth$sesionsPerDay)
  averageDaus[4] = mean(sesionsForthMonth$sesionsPerDay)
  
  averageDauMauPerMonth = averageDaus / maus
  averageDauMauPerMonth
  
  plot(averageDauMauPerMonth,
       xlab = "Months",
       ylab = "Average DAU/MAUU per month",
       type ="l",
       col = "blue")
  
```




# Métricas de Gameplay

## Número de sesiones por jugador
```{r, eval=TRUE, echo=TRUE}
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  userSessionFreq = data.frame(table(temp$UserID))
  averageNofSessions = mean(userSessionFreq$Freq)
  
  boxplot(userSessionFreq$Freq, 
          main = "Sesiones por usuario",
          names = c("Sesiones"),
          col = c("Green"),
          ylab = "Cantidad",
          xlab = "Sesiones"
          )
```

El número de sesiones de media por el total de usuarios es de **`r toString(format(round(averageNofSessions, 2), nsmall = 2))` sesiones**.

En el anterior gráfico observamos que la gran mayoría de los usuarios juegan entre 6 y 10 sesiones. También se percibe que como mínimo juegan una vez al juego y que los valores máximos normales son de unas 17 sesiones. A destacar, algunos usuarios que juegan más que los valores descritos y se convierten en excepciones de la población.



## Tiempo de juego

### ¿Cuánto es la media de tiempo destinada por los usuarios en sus sesiones de juego?
```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  userSessionsAverage = data.frame(summarise(group_by(temp,UserID), TimeSession = mean(SessionLenght)))
  userSessionsAverageSD = data.frame(summarise(group_by(temp,UserID), TimeSession = sd(SessionLenght)))
  AvgTimeSpent = mean(userSessionsAverage$TimeSession)
  AvgStandarDeviation = mean(userSessionsAverageSD$TimeSession)
  
  barplot(table(userSessionsAverage$TimeSession), 
          main = "Distribución por edad de los usuarios", 
          col = rainbow(length(table(userSessionsAverage$TimeSession))),
          ylab = "Usuarios (número de usuarios)",
          xlab = "Edad"
          )
  
```

ADVERTENCIA! Falta el comentario del Histogram...

## Tiempo entre sesiones

```{r eval=FALSE, include=FALSE}
  
  trackingData = GetTrackinData()
  usersData = GetUsersData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  result = data.frame(cbind(UserID = as.character(usersData$UserID), AverageTimeBetweenSessions = rep("", nrow(usersData))), stringsAsFactors = FALSE)
  
  #FOR a mejorar y optimizar ---> 6 minutos de cálculo...
  for(user in result$UserID){
    prevDate = 0
    sumTotal = 0
    dates = c(as.character(temp[which(temp$UserID == user),]$Date))
    if(length(dates)>1){
      for (date in dates) {
        if (prevDate!=0) {
            sumTotal = sumTotal + as.numeric(as.character((as_date(as.character(date)) - as_date(as.character(prevDate)))))
        }
        prevDate = date
      }
      result[which(result$UserID == user), "AverageTimeBetweenSessions"] = sumTotal/(length(dates)-1)
    }else{
      result[which(result$UserID == user), "AverageTimeBetweenSessions"] = 0
    }
  }
  
  boxplot(as.numeric(result$AverageTimeBetweenSessions), 
          main = "Tiempo entre sesiones por usuario",
          names = c("Días"),
          col = c("Green"),
          ylab = "Días",
          xlab = "Usuarios"
          )
  
```

En el gráfico se observa que la gran mayoria de usuarios tienen un tiempo entre sesiones sobre el rango de 3 a 5 días. En función del tipo de juego y la plataforma donde se encuentre, este gráfico puede valorarse negativamente o positivamente. Por ejemplo, en un juego móbil, podría verse que el tiempo entre sesión y sesión es elevado. En cambio, en un juego de consola, podría ser una medida buena. 

También se percibe que hay usuarios que vuelven al cabo de un lapso de días muy elevado.



## Retención

```{r, eval=TRUE, echo=TRUE}
#Descomentar y borrar el código activo
#Retention = RetentionOfTrackingData(GetTrackinData(), c(1,7,14,30))
Retention = c(1,7,14,30)
```

Al calcular la retención del juego con los datos de la muestra, se obtinen las siguientes retenciones en diferentes días.

Retención día 1: **`r toString(format(round(as.numeric(Retention[1]), 2), nsmall = 2))`**, retención día 7: **`r toString(format(round(as.numeric(Retention[2]), 2), nsmall = 2))`**, retención día 14: **`r toString(format(round(as.numeric(Retention[3]), 2), nsmall = 2))`** y la retención día 30: **`r toString(format(round(as.numeric(Retention[4]), 2), nsmall = 2))`**.


```{r, eval=FALSE, echo=TRUE}

daysToRetention = seq(from=1,to=30,by=1)
Retention = RetentionOfTrackingData(GetTrackinData(), daysToRetention)
plot(daysToRetention,Retention,
     xlab = "Días",
     ylab = "Retención",
     xlim = c(1,30),
     ylim = c(0,1),
     type ="l",
     col = "blue",
     )

```

El gráfico de retención es un tipo de gráfico común en muchos proyectos. Muestra una pendiente que desciende y que acaba estabilizándose con un número pequeño de de jugadores que siguen retenidos. Se destaca que a día 1 ya se ha perdido un 40% de los usuarios. 




# Métricas de la Indústria de los Videojuegos

## Tiempo de vida (Life Time)
```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Install"),]
  usersDateInstalledTheGame = data.frame(UserID=temp$UserID, DateInstall=temp$Date)

  temp = trackingData[which(trackingData$Action == "Uninstall"),]
  usersDateUninstalledTheGame = data.frame(UserID=temp$UserID, DateUnistall=temp$Date)

  usersDatesLifeTime = merge(usersDateInstalledTheGame,usersDateUninstalledTheGame, all.y=TRUE)

  usersDatesLifeTime = data.frame(usersDatesLifeTime,LifeTime=as_date(as.character(usersDatesLifeTime$DateUnistall)) - as_date(as.character(usersDatesLifeTime$DateInstall)))

  LT_average = mean(usersDatesLifeTime$LifeTime)

```

En el juego del estudio, los usuario tienen un tiempo de vida de media de **`r toString(format(round(as.numeric(LT_average), 2), nsmall = 2))` días**.



## Ingresos diarios (Daily Revenue)
#### Compute and plot the revenue per day and per month. Also compute the total revenue of the tracking period.

```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersDateSessionsMoneySpent = data.frame(UserID=temp$UserID, Date=temp$Date, Money=temp$MoneySpent, DateMonth=month(as.POSIXlt(temp$Date, format="%Y-%m-%d")))
  
  group_days = summarise(group_by(usersDateSessionsMoneySpent,Date),Revenue=sum(Money))

  plot(group_days,
     xlab = "Días",
     ylab = "Ingresos",
     xlim = c(0,120),
     ylim = c(0,max(group_days$Revenue)),
     type ="h",
     col = "blue",
     )
  
  boxplot(group_days$Revenue, 
          main = "Ingresos por día",
          names = c("Días"),
          col = c("Green"),
          ylab = "Ingresos",
          xlab = "Días"
          )

```

De la información que proporcionan los dos gráficos, se puede observar cómo hay un crecimiento de los ingresos por día que coincide con el crecimiento de jugadores, así como el los ingresos medios del día. Generalmente, se ingresa diariamente entre 1500 y 2000 unidades monetarias (se desconoze la moneda). 

```{r, eval=TRUE, echo=TRUE}
  
  group_months =summarise(group_by(usersDateSessionsMoneySpent,DateMonth), Revenue=sum(Money))
  
  plot(group_months,
     xlab = "Meses",
     ylab = "Ingresos",
     ylim = c(min(group_months$Revenue),max(group_months$Revenue)),
     type ="l",
     col = "blue",
     xaxt='n',
     )
  axis(side = 1,
       at = c(3,4,5,6),
       labels = c(group_months$DateMonth)
       )

  
  boxplot(group_months$Revenue, 
          main = "Ingresos por mes",
          names = c("Meses"),
          col = c("Green"),
          ylab = "Ingresos",
          xlab = "Meses"
          )
```

Al visualizar los dos gráficos referentes a los ingresos mensuales, se puede ver un subida de ingresos del primer mes al segundo, pero que después decrece del mes 5 al 6. Si se analizan los motivos de este decrecimiento, se descubrirá que el mes 6 no está completo en la muestra de datos. Por lo que este gráfico puede interpretarse de manera incorrecta sin dicha información.

Respecto a la media de ingresos por mes, se detalla que en cada mes se gana entre 45.000 y 60.000 unidades monetarias. Seguramente, el gráfico muestra unos datos con una desviación devido al mes 6.

```{r, eval=TRUE, echo=TRUE}
  revenue = sum(usersDateSessionsMoneySpent$Money)
```

Si se calcula el importe referente a los ingresos generados durante el período de seguimiento, se obtiene un importe de **`r toString(format(round(revenue, 2), nsmall = 2))` unidades monetarias**.



## Ratio de conversión (CR)

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData()
  usersData = GetUsersData()
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersMoneySpent = data.frame(UserID=temp$UserID, Money=temp$MoneySpent)
  usersMoneySpent = usersMoneySpent[usersMoneySpent$Money>0,]
  usersMoneySpent = data.frame(summarise(group_by(usersMoneySpent,UserID), Revenue=sum(Money)))
  
  CR = nrow(usersMoneySpent)/nrow(usersData)
  
```
El ratio de conversión del juego es del **`r toString(format(round(CR * 100, 2), nsmall = 2))` %**. Se trata de un ratio muy elevado, ya que significa que más de la mitad de los usuarios han realizado algún pago en el juego. Generalemente es un valor muy inferior al resultado obtenido, aunque puede variar mucho según el tipo de juego y su modelo de ingresos. Se está comparando este ratio con los juegos F2P.



## ARPU y ARPPU

```{r, eval=TRUE, echo=TRUE}

  trackingData = GetTrackinData()
  usersData = GetUsersData()  
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersMoneySpent = data.frame(UserID=temp$UserID, Money=temp$MoneySpent)
  usersMoneySpent = usersMoneySpent[usersMoneySpent$Money>0,]
  usersMoneySpent = data.frame(summarise(group_by(usersMoneySpent,UserID), Revenue=sum(Money)))

  TotalRevenue = sum(usersMoneySpent$Revenue) 
  Users = nrow(data.frame(summarise(group_by(usersData, UserID))))
  PayUsers = nrow(usersMoneySpent)

  ARPU = TotalRevenue/Users
  ARPPU = TotalRevenue/PayUsers

```

Una vez se ha obtenido las métricas de ARPU (**`r toString(format(round(ARPU, 2), nsmall = 2))`**) y ARPPU (**`r toString(format(round(ARPPU, 2), nsmall = 2))`**), se puede observar cuanto dinero se gastan de manera aproximada o estimada cada usuario (en el caso del ARPU) y cuanto dinero los usuarios que han pagado. Se trata de unos valores que proporcionan información sobre el valor de los usuarios respecto los ingresos totales. De hecho, el ARPPU es más interesante, ya que según esta estimación, los usuarios que pagan, pagarían 77 unidades monetarias.



## LTV por usuario
```{r, eval=TRUE, echo=TRUE}
  
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Uninstall"),]
  usersChurn = data.frame(UserID=temp$UserID)
  
  temp = trackingData[which(trackingData$Action == "Session"),]
  usersMoneySpent = data.frame(UserID=temp$UserID, Money=temp$MoneySpent)
  usersMoneySpent = data.frame(summarise(group_by(usersMoneySpent,UserID), Revenue=sum(Money)))
  
  usersLTV = merge(usersChurn,usersMoneySpent, all.x=TRUE)
  usersLTV[is.na(usersLTV$Revenue),'Revenue'] = 0
  
  boxplot(usersLTV$Revenue, 
          main = "LTV",
          names = c("Usuarios"),
          col = c("Green"),
          ylab = "Ingresos",
          xlab = "Usuarios"
          )
```

La información que se extrae de este boxplot es el rango de ingresos que proporcionan los usuarios durante toda su vida en el juego. Se observa que la gran mayoría realizan muy pocas aportaciones o ninguna, ya que el valor intermedio está muy próximo al mínimo de ingresos.


```{r, eval=TRUE, echo=TRUE}
  LTV = mean(usersLTV$Revenue)
```

De media, la métrica del LTV de este juego es de: **`r toString(format(round(LTV, 2), nsmall = 2))`** unidades monetarias.





# Test A/B

## Retención
### ¿De qué tipo de inferencia se trata?
```{r, eval=TRUE, echo=TRUE}
  trackingData = GetTrackinData()
  temp = trackingData[which(trackingData$Action == "Install"),]
  dates = unique(as.character(temp$Date))
  
  retentionsA= rep(0, length(dates))
  retentionsB = rep(0, length(dates))
  index = 1
  for(date in dates){
      users = data.frame(UserID=as.character(temp[temp$Action == "Install" & as.character(temp$Date) == as.character(date),]$UserID))
      
      usersA = c(as.character(users[which(grepl("ID1" , users$UserID)),]))
      usersB = c(as.character(users[which(grepl("ID2" , users$UserID)),]))
     
      resultA = trackingData[which(is.element(as.character(trackingData$UserID), usersA)),]
      resultB = trackingData[which(is.element(as.character(trackingData$UserID), usersB)),]
    
      retentionsA[index]=RetentionOfTrackingData(resultA, c(14))
      retentionsB[index]=RetentionOfTrackingData(resultB, c(14))
      
      index=index+1
  }
  
  #Fix values sin retención
  retentionsA = retentionsA[1:105]
  retentionsB = retentionsB[1:105]
  
```

**ADVERTENCIA!** Aquí comentarios sobre la muestra y sobre inferencia...



### Hipótesis nula y alternativa
**Hº:** Version 1 = Version 2.
**H':** Version 1 != Version 2.



### Método apropiado para el estudio
**ADVERTENCIA!** traducir... (no se ha traducido por si hay cambios de método)
Due to the fact that we face a dataframe far beyond the 30's limit of T-student we should use the Normal Distribution. Also we currently have a bilateral graph.



### Prueba de hipótesis. ¿Qué tipo de "cola" es?
```{r, eval=FALSE, echo=TRUE}

#4 Compute the hypothesis testing

##Group1 <- c(result$AverageTimeBetweenSessions)
##length(Group1) <- length(Group1) / 100
##Group2 <- c(sort(result$AverageTimeBetweenSessions, decreasing = TRUE))
##length(Group2) <- length(Group2) / 100

#Table1 <- data.frame(as.numeric(Group1) , as.numeric(Group2))

#str(Table1)


MeanGroup1 <- mean(retentionsA, na.rm = TRUE)
MeanGroup2 <- mean(retentionsB, na.rm = TRUE)

help(sd)

StandardDeviationGroup1 <- sd(retentionsA, na.rm = TRUE)
StandardDeviationGroup2 <- sd(retentionsB, na.rm = TRUE)

n1 <- length(retentionsA)
n2 <- length(retentionsB)

#retentionC <- as.data.frame(retentionsA - retentionsB)

df <- n1 + n2 - 2

q <- qnorm(0.025, lower.tail = FALSE)

s <- sqrt((((n1-1)*(StandardDeviationGroup1^2))+((n2-1)*(StandardDeviationGroup2^2))))/df

zobs <- (MeanGroup1 - MeanGroup2) / s * sqrt((1/n1) + (1/n2))

#tobs <- (MeanGroup1 - MeanGroup2) / s * sqrt((1/n1) + (1/n2))

#Quantile <- qt(0.05, df, lower.tail = TRUE)
```
**ADVERTENCIA!** Aquí comentarios sobre el tema...


### Calcular el p-value
```{r, eval=FALSE, echo=TRUE}
#pt(tobs, df, lower.tail = TRUE)
pnorm(zobs, lower.tail = FALSE)
```
**ADVERTENCIA!** Aquí comentarios sobre el tema...

### Interpretar resultados
**ADVERTENCIA!** Aquí comentarios sobre el tema...




## Tiempo de juego de los usuarios 
```{r, eval=TRUE, echo=TRUE}
#
trackingData = GetTrackinData()

temp = trackingData[which(trackingData$Action == "Session"),]

UsuariosVersion1 <- temp[which(grepl("ID1" , temp$UserID)),]
UsuariosVersion2 <- temp[which(grepl("ID2" , temp$UserID)),]

MG1 <- summarise(group_by(UsuariosVersion1, UserID), mean(SessionLenght))
MG2 <- summarise(group_by(UsuariosVersion2, UserID), mean(SessionLenght))

mean(MG1$`mean(SessionLenght)`)
mean(MG2$`mean(SessionLenght)`)

SDMG1 <- sd(UsuariosVersion1$SessionLenght)
SDMG2 <- sd(UsuariosVersion2$SessionLenght)


n1.1 <- length(UsuariosVersion1$SessionLenght)
n2.2 <- length(UsuariosVersion2$SessionLenght)

df2 <- (n1.1 + n2.2) - 2

q2 <- qnorm(0.05, lower.tail = FALSE)

s2 <- sqrt((((22207 * 8281) + (22065 * 3600)) / 44270)) 

zobs2 <- ((93.713) / (s2 * (sqrt(1/n1.1 + 1/n2.2))))

pnorm(zobs2, lower.tail = FALSE)

```



# Clustering
```{r, eval=TRUE, echo=TRUE}

library(ggplot2)

# A) sex                                 --> Encontrado directamene en la base de datos  
# B) age                                 --> Encontrado directamenete en la base de datos
# C) average playing time per sesion
# D) amount spent by the user
# E) amount spent by the user respect the number of sesions
# F) number of sesions of the user

  usersData = GetUsersData()
  trackingData = GetTrackinData()
  
  usersSex  = rep(-1,length(usersData$UserID))
  averagePlayingTimePerSesion = rep(-1,length(usersData$UserID))  # tiempo medio de juego por sesion 
  moneySpent = rep(-1,length(usersData$UserID))                   # dinero gastado por cada usuario
  numberOfSesions = rep(-1,length(usersData$UserID))              # sesiones por usuario
  moneyPerSesion = rep(-1,length(usersData$UserID))               # money spent / sesions
  
  counter = 1
  for (user in usersData$UserID) {
    
    # Busca todos los eventos relacionados con el usuario en cuestion
    userExtractedData = trackingData[trackingData$UserID == user,]
    userExtractedData = userExtractedData[userExtractedData$Action == "Session",]
    
    # B) Sex of user ---------------------------------------------------------------------
    if (usersData[usersData$UserID == user,]$sex == "M")
      usersSex[counter] = -1   # Male
    else 
      usersSex[counter] = 1   # Female
    
    # C) average playing time per sesion of each user ------------------------------------
    sesionsLenght = as.numeric( userExtractedData[userExtractedData$UserID == user,]$SessionLenght )
    averagePlayingTimePerSesion[counter] = mean(sesionsLenght)
    
    # F) number of sesions of the user ---------------------------------------------------
    sesionsAmount = length(sesionsLenght)
    numberOfSesions[counter] = sesionsAmount
    
    # D) amount spent by the user ---------------------------------------------------------
    money = sum( userExtractedData[userExtractedData$UserID == user,]$MoneySpent , na.rm = TRUE)
    moneySpent[counter] = money
    
    # E) amount spent by the user respect the number of sesions ---------------------------
    moneySpentPerSesion = money / sesionsAmount
    moneyPerSesion[counter] = moneySpentPerSesion

    # Aumentamos el counter 
    counter = counter + 1
  }
  
  # unifica los datos encontrados en un solo data frame
  usersAglomeratedData = data.frame( as.numeric(usersData$age))
  usersAglomeratedData$Sex = factor(  usersSex)
  usersAglomeratedData$NumberOfSesions = as.numeric(  numberOfSesions)
  usersAglomeratedData$averageSesionTime = averagePlayingTimePerSesion
  usersAglomeratedData$MoneySpent =  moneySpent 
  usersAglomeratedData$MoneySpentPerSesion = moneyPerSesion
  
  # Limpieza 
  usersAglomeratedData = usersAglomeratedData[usersAglomeratedData$NumberOfSesions != 0,]
  colnames(usersAglomeratedData) = c("Age", 
                                     "Sex", 
                                     "Nº Sesions", 
                                     "Average Session Time", 
                                     "Money spent" , 
                                     "Money spent per Session")
  
  # CLUSTERING ---------------------------------------------------------------------
  CalculateClusteringWIthKmeans = function (inputData,kValue, nStart) 
  {
    result <- kmeans(inputData,centers = kValue, nstart = nStart)
    return(result) 
  }
  
  resultKTwo = CalculateClusteringWIthKmeans(usersAglomeratedData,2,50)
  resultKThree = CalculateClusteringWIthKmeans(usersAglomeratedData,3,50)
  resultSeven = CalculateClusteringWIthKmeans(usersAglomeratedData,7,50)
  
```

**ADVERTENCIA:**
El identificador numerico usado en las siguientes explicaciones de cada grupo puede variar dependiendo de la ejecucion de KMeans. 

**K = 2**

```{r, eval=TRUE, echo=TRUE}
resultKTwo

pie (table( resultKTwo$cluster),
     main = "Agrupacion con k = 2")

```

Cuando vemos los resultados de "resultTwo" podemos ver que usando un valor de k de 2 se forman dos grupos muy discriminados por el valor de "Money Spent" y "Money spent por session". La diferencia a parte de esta es el sexo donde en el caso del grupo 1 nos encontramos con que es un grupo formado en su gran mayoria por hombres. En el segundo grupo encontramos una mayoria marginal de mugeres. 

Tambien es importante darse cuenta de la diferencia de edad de ambos grupos. El primero, el mayoritariamente formado en su totalidad por hombres encontramos que la edad es menor que el grupo formado por una mezcla de ambos sexos.

En cuanto a la cantidad de elementos en cada uno de los clusters encontramos que la mayoria de las instancias estan en el cluster 2 (cluster mixto) mientras que una minoria se encuentra en el cluster 1 (clauster unicamente de hombres). Estas asunciones sobre el sexo de cada grupo podemos hacerlas debido a que usamos el sexo como valor numerico siendo -1 Hombre y 1 Mujer. Si el valor tiende a uno de estos valores podemos llegar a sber que % de hombres y mujeres forman parte de ese cluster.

**K = 3**

```{r, eval=TRUE, echo=TRUE}
resultKThree

pie (table( resultKThree$cluster),
     main = "Agrupacion con k = 3")
```

En el caso de utilizar k = 3 nos encontramos con que el output esta formado por 3 grupos (como es de esperar). 

En cuanto a la edad y el sexo de los elementos del cluster encontramos una agrupacion similar a la del resultado de k = 3. Un grupo parece estar plenamente formado por hombres (grupo 1) mientras que el grupo 2 parece estar fomrado casi en su totalidad por mujeres con una edad rondando los 45 años. En este caso es el tercer grupo el cual esta formado de una amalgama de hombres y mujeeres.

En cuanto al tiempo de juego encontramos que el claro ganador (en cuanto a cantidad) es el tercer grupo (grupo mixto) ya que tiene la mayor cantidad de horas. Ademas este grupo gasta poco en total y poco por sesion. Tambien es el grupo que menos juega. El segundo grupo juega algo mas aunque sus sesiones son mas cortas que las del grupo 3 y 1. Este grupo ademas gasta menos que el grupo 1 y 3 siendo entonces el qu emenos gasta por sesion y en total. Es el grupo 1, el grupo formado exclusivamente por hombres, el que mas ha gastado por sesion y en total. Esto es curioso ya que puede contradecir el estudio inicial.

En este caso el grupo con mayor cantidad de instancias es el 3 (grupo mixto en cuanto a sexo y el que menos sesiones ha tenido --> mas casual). Se ve seguido de cerca del grupo 2 siendo el grupo 1 el utlimo en cuanto a instancias (una cuarta parte de la muestra)

**K = 7**

```{r, eval=TRUE, echo=TRUE}
resultSeven

pie (table( resultSeven$cluster),
     main = "Agrupacion con k = 7")
```

En el momento que decidimos optar por la formacion de mas clusters añadimos error. Este error es observable en que los clusters que son formados comparten algunos entre ellos atribuos con valores muy similares (vease cluster 1 y cluster 2). Dando una vista rapida se puede observar una presencia importante (50% de los clusters) de hombres que componen clusters enteros (clusters 3, 5 , 6 y 7). A parte de esto nos encontramos con que el cluster 1 y 2 sumados suman un total superior al 50% de la muestra. Esto nos puede indicar junto con el hecho de tener clusters muy similares entre ellos que los resultados pueden ser de no gran utiliad.

Dentro del caos aparente de esta prueba podemos observar la presencia de dos grupos (cluster 3 y 6) donde aparecen grandes cantidades de dinero gastado. Lo curioso es que en estos grupos son todo hombres relativamente jovenes (teniendo en cuenta el segmento de la muestra).

**CONCLUSION CLUSTERING**

Tras llevar a cabo varios ejercicios de clustering podemos observar una tendencia bastante pronunciada a la discriminacion de clusters mediante el sexo y sobre el dinero gastado en total y po rsesion. Esto nos indica que existe una disparidad importante en estos atributos (al menos es lo que se interpreta de los clusters que han surgido como resultado) y que son valores clave en la separacion en grupos.

```{r, eval=TRUE, echo=TRUE}

  resultKTwo$centers

  resultKThree$centers
  
  resultSeven$centers

```

Si planteamos cada cluster como el individuo "perfecto" de cada agrupacion cuando trabajamos con **2 como valor de k** encontramos que:
  - Los hombres **gastan mas** que las mujeres , **juegan mas** pero tienen **sesiones mas cortas**.
  - Los hombres son por lo general **mas jovenes** que las mujeres que juegan a este juego.
  
Si nos fijamos en la agrupacion con **k=3**
  - Los hombres **gastan mas** que las mujeres , **juegan mas** pero tienen **sesiones mas cortas**.
  - Existe un grupo que supera el 30% de tamaño que **no gasta casi dinero** formado por un mix tanto de hombres como de mujeres donde existe una mayor cantidad de mujeres.
  
Si nos fijamos en la agrupacion con **K = 7**
  - Los hombres **gastan mas** que las mujeres , **juegan mas** pero tienen **sesiones mas cortas**.
  - Existe una separacion importante entre **quien gasta mas y quien menos**
  - Por lo general las **mujeres juegan mas**  de forma **mas esporadica**
  


# Conclusiones








